import std::buffer::Buffer
import std::fs
import std::zlib
import std::hash::sha1::SHA1Hash
import std::sort::sort_by
import std::traits::compare
import std::time


struct TreeElement {
    mode: str
    filename: str
    hash: str
}



struct Commit {
    tree_hash: str
    parent_hashes: $[str]
    author: str
    author_timestamp: i64
    author_timezone: str
    committer: str
    committer_timestamp: i64
    committer_timezone: str
    message: str
}

def Commit::free(&this) {
    .tree_hash.free()
    for parent in .parent_hashes.iter() {
        parent.free()
    }
    .parent_hashes.free()
    .author.free()
    .author_timezone.free()
    .committer.free()
    .committer_timezone.free()
    .message.free()
    std::mem::free(this)
}

def TreeElement::free(this) {
    .filename.free()
    .mode.free()
    .hash.free()
}

enum Object {
    Blob(buf:Buffer)
    Tree(li:$[TreeElement])
    Commit(commit:&Commit)
}

def Object::free(this) {
    match this {
        Blob(buf) => buf.free()
        Commit(commit) => commit.free()
        Tree(li) => {
            for element in li.iter() {
                element.free()
            }
            li.free()
        }
    }
}

def get_object_filename(hash: str): str {
    return f".git/objects/{hash[0]}{hash[1]}/{hash + 2}"
}

def decompress_object(path: str): Buffer {
    let file = fs::read_file(path)
    let contents = zlib::decompress(file)
    file.free()
    return contents
}

def get_object(hash: str): Object {
    let path = get_object_filename(hash)
    let contents = decompress_object(path)
    defer contents.free()
    path.free()
    let sv = contents.sv()
    let header = sv.chop_word()
    let length = sv.chop_i32()
    sv.chop_left()

    match(header) {
        "blob" => {
            let data = Buffer::from_sv(sv)
            return Blob(data)
        }
        "tree" => {
            let li: $[TreeElement] = $[]
            while sv.len > 0 {
                let mode = sv.chop_word().copy_data_to_cstr()
                let filename = sv.chop_by_delim('\0').copy_data_to_cstr()
                
                let hash_bytes = sv.chop_left(20)
                let sha1: SHA1Hash
                std::libc::memcpy(sha1.data, hash_bytes.data, 20)
                let hash_str = sha1.stringify()

                let tree_entry = TreeElement(mode, filename, hash_str)
                li += tree_entry
            }
            return Tree(li)
        }
        else => std::panic(f"Not yet implemented for {header}")
    }


}

def hash_object(object: Object, write: bool): str {
    let out = Buffer::make()
    match object {
        Blob(buf) => {
            out <<= f"blob {buf.size}"
            out += '\0'
            out += &buf
        }
        Tree(li) => {
            let data = Buffer::make()
            for entry in li.iter() {
                data <<= f"{entry.mode} {entry.filename}"
                data += '\0'
                let sha1 = SHA1Hash::parse_string_hash(entry.hash)
                data.write_bytes(sha1.data, 20)
            }
            out <<= f"tree {data.size}"
            out += '\0'
            out <<= &data
        }
        Commit(commit) => {
            let data = Buffer::make()
            data <<= f"tree {commit.tree_hash}\n"
            for parent in commit.parent_hashes.iter() {
                data <<= f"parent {parent}\n"
            }
            data <<= f"author {commit.author} {commit.author_timestamp} {commit.author_timezone}\n"
            data <<= f"committer {commit.committer} {commit.committer_timestamp} {commit.committer_timezone}\n\n"
            data += commit.message

            out <<= f"commit {data.size}"
            out += '\0'
            out <<= &data
        }
    }


    let hash = SHA1Hash::from(out)
    let hash_str = hash.stringify()
    let path = get_object_filename(hash_str)
    if write {
        fs::create_directory(f".git/objects/{hash_str[0]}{hash_str[1]}", exists_ok:true)
        let compressed_file = zlib::compress(out)

        // write_file would not overwrite an existing file
        if not fs::file_exists(path) fs::write_file(path, compressed_file)

        path.free()
        compressed_file.free()
    }
    return hash_str
}

def create_blob(path: str): Object {
    let file = fs::read_file(path)
    return Blob(file)
}

def create_tree(path: str): Object {
    let tree_li: $[TreeElement] = $[]
    for entry in fs::iterate_directory(path) {
        if entry.name == ".git" continue
        match(entry.type) {
            File => {
                let mode = "100644".copy()
                let name = entry.name.copy()
                let blob = create_blob(f"{path}/{entry.name}")
                let hash = hash_object(blob, write:true)
                blob.free()
                tree_li += TreeElement(mode, name, hash)
            }
            Directory => {
                let mode = "40000".copy()
                let name = entry.name.copy()
                let tree = create_tree(f"{path}/{entry.name}")
                let hash = hash_object(tree, write:true)
                tree.free()
                tree_li += TreeElement(mode, name, hash)
            }
            else => {}
            // SymbolicLink => {
            //     object <<= f"120000 "
            // }
        }
    }
    sort_by<TreeElement>(tree_li.data, tree_li.size, |a,b|{
        if a.mode.eq(b.mode) {
            return a.filename.compare(b.filename)
        } else {
            return -a.mode[0].compare(b.mode[0])
        }
    })
    return Tree(tree_li)
}

def create_commit(tree_hash: str, parent_hashes: $[str], message: str): Object {
    // FIXME: Need to get the actual author and committer from the environment
    let user = "Unknown User <unknown@example.com>"
    let timezone = Buffer::make(capacity: 6)
    defer timezone.free()
    let t = time::time(null)
    let timeinfo = time::localtime(&t)
    timezone.size += time::strftime(timezone.data as str, 6, "%z", timeinfo)
    let timestamp = t as i64

    let commit = @new Commit(
        tree_hash.copy(), 
        parent_hashes, 
        author:user.copy(), 
        author_timestamp:timestamp, 
        author_timezone:timezone.new_str(),
        committer: user.copy(),
        committer_timestamp:timestamp, 
        committer_timezone:timezone.new_str(),
        message.copy(),
    )

    return Commit(commit)
}