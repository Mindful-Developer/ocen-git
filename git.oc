import std::buffer::Buffer
import std::fs
import std::zlib
import std::hash::sha1::SHA1Hash
import std::sort::sort_by
import std::traits::compare
import std::time


struct TreeElement {
    mode: str
    filename: str
    hash: str
}

def TreeElement::free(this) {
    .filename.free()
    .mode.free()
    .hash.free()
}

struct Commit {
    tree_hash: str
    parent_hashes: $[str]
    author: str
    author_timestamp: i64
    author_timezone: str
    committer: str
    committer_timestamp: i64
    committer_timezone: str
    message: str
}

def Commit::free(&this) {
    .tree_hash.free()
    for parent in .parent_hashes.iter() {
        parent.free()
    }
    .parent_hashes.free()
    .author.free()
    .author_timezone.free()
    .committer.free()
    .committer_timezone.free()
    .message.free()
    std::mem::free(this)
}

struct Entry {
    ctime_seconds: u32,
    ctime_nanoseconds: u32,
    mtime_seconds: u32,
    mtime_nanoseconds: u32,
    dev: u32,
    ino: u32,
    mode: u32,
    uid: u32,
    gid: u32,
    size: u32,
    sha1: str,
    flags: u16,
    assume_valid: bool,
    extended: bool,
    stage: u16,
    path: str,
}

def Entry::free(&this) {
    .sha1.free()
    .path.free()
    std::mem::free(this)
}

struct Index {
    signature: str,
    version: u32,
    num_entries: u32,
    entries: $[&Entry],
}

def Index::free(&this) {
    .signature.free()
    for entry in .entries.iter() {
        entry.free()
    }
    .entries.free()
    std::mem::free(this)
}

def Index::from_buf(file: Buffer): &Index {
    let reader = file.reader()
    
    let signature = reader.read_bytes_sv(4)
    let version = reader.read_u32()
    let num_entries = reader.read_u32()
    let entries: $[&Entry] = $[]

    for let i = 0; i < num_entries as u32; i += 1 {
        let ctime_seconds = reader.read_u32()
        let ctime_nanoseconds = reader.read_u32()
        let mtime_seconds = reader.read_u32()
        let mtime_nanoseconds = reader.read_u32()
        let dev = reader.read_u32()
        let ino = reader.read_u32()
        let mode = reader.read_u32()
        let uid = reader.read_u32()
        let gid = reader.read_u32()
        let size = reader.read_u32()
        let sha1_sv = reader.read_bytes_sv(20)
        let sha1: SHA1Hash
        std::libc::memcpy(sha1.data, sha1_sv.data, 20)
        let hash_str = sha1.stringify()
        let flags = reader.read_u16()
        let assume_valid = ((flags >> 15) & 0b1) != 0
        let extended = ((flags >> 14) & 0b1) != 0
        let stage = (flags >> 12) & 0b11
        let name_length = flags & 0xFFF
        let path = reader.read_bytes_sv(name_length as u32).copy_data_to_cstr()
        let total_entry_size = 62 + name_length as u32
        let padding = (8 - total_entry_size % 8)
        reader.read_bytes_sv(padding)

        let entry = @new Entry (
            ctime_seconds,
            ctime_nanoseconds,
            mtime_seconds,
            mtime_nanoseconds,
            dev,
            ino,
            mode,
            uid,
            gid,
            size,
            hash_str,
            flags,
            assume_valid,
            extended,
            stage,
            path
        )
        entries.push(entry)
    }
    

    return @new Index(
        signature.copy_data_to_cstr(),
        version,
        num_entries,
        entries
    )
}

def Index::to_buf(&this): Buffer {
    let buf = Buffer::make()
    buf.write_bytes(.signature, 4)
    buf.write_u32(.version)
    buf.write_u32(.num_entries)

    for entry in .entries.iter() {
        buf.write_u32(entry.ctime_seconds)
        buf.write_u32(entry.ctime_nanoseconds)
        buf.write_u32(entry.mtime_seconds)
        buf.write_u32(entry.mtime_nanoseconds)
        buf.write_u32(entry.dev)
        buf.write_u32(entry.ino)
        buf.write_u32(entry.mode)
        buf.write_u32(entry.uid)
        buf.write_u32(entry.gid)
        buf.write_u32(entry.size)
        let sha1 = SHA1Hash::parse_string_hash(entry.sha1)
        buf.write_bytes(sha1.data, 20)
        buf.write_u16(entry.flags)
        buf.write_bytes(entry.path, entry.path.len())

        // 1-8 nul bytes as necessary to pad the entry to a multiple 
        // of eight bytes while keeping the name NUL-terminated.
        let total_entry_size = 62 + entry.path.len()
        let padding = (8 - total_entry_size % 8)
        for let i = 0; i < padding; i += 1 {
            buf.write_u8(0)
        }
    }
    let sha1 = SHA1Hash::from(buf)
    buf.write_bytes(sha1.data, 20)

    return buf
}

def Index::add_entry(&this, path: str) {
    let stats = fs::file_info(path)
    let blob = create_blob(path)
    let hash_str = hash_object(blob, write:true)
    blob.free()

    let new_entry = @new Entry(
        stats.ctime.tv_sec as u32,
        stats.ctime.tv_nsec as u32,
        stats.mtime.tv_sec as u32,
        stats.mtime.tv_nsec as u32,
        stats.dev as u32,
        stats.ino as u32,
        stats.mode,
        stats.uid,
        stats.gid,
        stats.size as u32,
        hash_str,
        flags: path.len() as u16,
        false,
        false,
        0,
        path
    )

    let existing = .entries.find(|e|=>e.path == path)
    if existing >= 0 { 
        .entries.data[existing].free()
        .entries.data[existing] = new_entry
    } else {
        .entries.push(new_entry)
        .num_entries += 1
        sort_by<&Entry>(.entries.data, .entries.size, |a,b|=>a.path.compare(b.path))
    }
}

def Index::dump(this) {
    println(f"signature: {.signature}")
    println(f"version: {.version}")
    println(f"num_entries: {.num_entries}")

    for entry in .entries.iter() {
        println(f"\n\tpath: {entry.path}")
        println(f"\tctime_seconds: {entry.ctime_seconds}")
        println(f"\tctime_nanoseconds: {entry.ctime_nanoseconds}")
        println(f"\tmtime_seconds: {entry.mtime_seconds}")
        println(f"\tmtime_nanoseconds: {entry.mtime_nanoseconds}")
        println(f"\tdev: {entry.dev}")
        println(f"\tino: {entry.ino}")
        println(f"\tmode: {entry.mode}")
        println(f"\tuid: {entry.uid}")
        println(f"\tgid: {entry.gid}")
        println(f"\tsize: {entry.size}")
        println(f"\tsha1: {entry.sha1}")
        println(f"\tflags: {entry.flags}")
    }
}

enum Object {
    Blob(buf:Buffer)
    Tree(li:$[TreeElement])
    Commit(commit:&Commit)
}

def Object::free(this) {
    match this {
        Blob(buf) => buf.free()
        Commit(commit) => commit.free()
        Tree(li) => {
            for element in li.iter() {
                element.free()
            }
            li.free()
        }
    }
}

def get_object_filename(hash: str): str {
    return f".git/objects/{hash[0]}{hash[1]}/{hash + 2}"
}

def decompress_object(path: str): Buffer {
    let file = fs::read_file(path)
    let contents = zlib::decompress(file)
    file.free()
    return contents
}

def get_object(hash: str): Object {
    let path = get_object_filename(hash)
    let contents = decompress_object(path)
    defer contents.free()
    path.free()
    let sv = contents.sv()
    let header = sv.chop_word()
    let length = sv.chop_i32()
    sv.chop_left()

    match(header) {
        "blob" => {
            let data = Buffer::from_sv(sv)
            return Blob(data)
        }
        "tree" => {
            let li: $[TreeElement] = $[]
            while sv.len > 0 {
                let mode = sv.chop_word().copy_data_to_cstr()
                let filename = sv.chop_by_delim('\0').copy_data_to_cstr()
                
                let hash_bytes = sv.chop_left(20)
                let sha1: SHA1Hash
                std::libc::memcpy(sha1.data, hash_bytes.data, 20)
                let hash_str = sha1.stringify()

                let tree_entry = TreeElement(mode, filename, hash_str)
                li += tree_entry
            }
            return Tree(li)
        }
        else => std::panic(f"Not yet implemented for {header}")
    }


}

def hash_object(object: Object, write: bool): str {
    let out = Buffer::make()
    match object {
        Blob(buf) => {
            out <<= f"blob {buf.size}"
            out += '\0'
            out += &buf
        }
        Tree(li) => {
            let data = Buffer::make()
            for entry in li.iter() {
                data <<= f"{entry.mode} {entry.filename}"
                data += '\0'
                let sha1 = SHA1Hash::parse_string_hash(entry.hash)
                data.write_bytes(sha1.data, 20)
            }
            out <<= f"tree {data.size}"
            out += '\0'
            out <<= &data
        }
        Commit(commit) => {
            let data = Buffer::make()
            data <<= f"tree {commit.tree_hash}\n"
            for parent in commit.parent_hashes.iter() {
                data <<= f"parent {parent}\n"
            }
            data <<= f"author {commit.author} {commit.author_timestamp} {commit.author_timezone}\n"
            data <<= f"committer {commit.committer} {commit.committer_timestamp} {commit.committer_timezone}\n\n"
            data += commit.message

            out <<= f"commit {data.size}"
            out += '\0'
            out <<= &data
        }
    }


    let hash = SHA1Hash::from(out)
    let hash_str = hash.stringify()
    let path = get_object_filename(hash_str)
    if write {
        fs::create_directory(f".git/objects/{hash_str[0]}{hash_str[1]}", exists_ok:true)
        let compressed_file = zlib::compress(out)

        // write_file would not overwrite an existing file
        if not fs::file_exists(path) fs::write_file(path, compressed_file)

        path.free()
        compressed_file.free()
    }
    return hash_str
}

def create_blob(path: str): Object {
    let file = fs::read_file(path)
    return Blob(file)
}

def create_tree(path: str): Object {
    let tree_li: $[TreeElement] = $[]
    for entry in fs::iterate_directory(path) {
        if entry.name == ".git" continue
        match(entry.type) {
            File => {
                let mode = "100644".copy()
                let name = entry.name.copy()
                let blob = create_blob(f"{path}/{entry.name}")
                let hash = hash_object(blob, write:true)
                blob.free()
                tree_li += TreeElement(mode, name, hash)
            }
            Directory => {
                let mode = "40000".copy()
                let name = entry.name.copy()
                let tree = create_tree(f"{path}/{entry.name}")
                let hash = hash_object(tree, write:true)
                tree.free()
                tree_li += TreeElement(mode, name, hash)
            }
            else => {}
            // SymbolicLink => {
            //     object <<= f"120000 "
            // }
        }
    }
    sort_by<TreeElement>(tree_li.data, tree_li.size, |a,b|{
        if a.mode.eq(b.mode) {
            return a.filename.compare(b.filename)
        } else {
            return -a.mode[0].compare(b.mode[0])
        }
    })
    return Tree(tree_li)
}

def create_commit(tree_hash: str, parent_hashes: $[str], message: str): Object {
    // FIXME: Need to get the actual author and committer from the environment
    let user = "Unknown User <unknown@example.com>"
    let timezone = Buffer::make(capacity: 6)
    defer timezone.free()
    let t = time::time(null)
    let timeinfo = time::localtime(&t)
    timezone.size += time::strftime(timezone.data as str, 6, "%z", timeinfo)
    let timestamp = t as i64

    let commit = @new Commit(
        tree_hash.copy(), 
        parent_hashes, 
        author:user.copy(), 
        author_timestamp:timestamp, 
        author_timezone:timezone.new_str(),
        committer: user.copy(),
        committer_timestamp:timestamp, 
        committer_timezone:timezone.new_str(),
        message.copy(),
    )

    return Commit(commit)
}