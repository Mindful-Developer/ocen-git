import std::fs
import std::shift_args
import std::libc::unistd::chdir
import std::argparse::Parser
import git::{this, get_object, create_blob, create_tree, create_commit}


def main(argc: i32, argv: &str) {
    shift_args(&argc, &argv)
    let subcommand = shift_args(&argc, &argv)

    match subcommand {
        "init" => initialize_repo(argc, argv)
        "cat-file" => cat_file(argc, argv)
        "hash-object" => hash_object(argc, argv)
        "ls-tree" => ls_tree(argc, argv)
        "write-tree" => write_tree()
        "commit-tree" => commit_tree(argc, argv)
        "update-index" => update_index(argc, argv)
        else => std::panic("Wrong subcommand, stupid!")
    }
}



def initialize_repo(argc: i32, argv: &str) {
    if argc > 0 {
        let dir = shift_args(&argc, &argv)
        if fs::directory_exists(dir) std::panic("Error: Directory exists")
        fs::create_directory(dir)
        chdir(dir)
    }

    if fs::directory_exists(".git") std::panic("Error: Repo exists")
    fs::create_directory(".git")
    fs::create_directory(".git/hooks")
    fs::create_directory(".git/info")
    fs::create_directory(".git/objects")
    fs::create_directory(".git/refs")
    fs::create_directory(".git/refs/heads")
    fs::create_directory(".git/refs/tags")
    fs::write_file_str(".git/HEAD", "ref: refs/heads/main\n")
    fs::write_file_str(".git/config", "")
    fs::write_file_str(".git/description", "Unnamed repository; edit this file 'description' to name the repository.")
}


def cat_file(argc: i32, argv: &str) {
    let hash = shift_args(&argc, &argv)
    let pprint = false

    if hash == "-p" {
        hash = shift_args(&argc, &argv)
        pprint = true
    }

    let contents = get_object(hash)
    
    if contents is Blob(buf) print(f"{buf}")
}

def hash_object(argc: i32, argv: &str) {
    let file = shift_args(&argc, &argv)
    let write = false 

    if file == "-w" {
        write = true
        file = shift_args(&argc, &argv)
    }

    let object = create_blob(file)
    let hash = git::hash_object(object, write)
    println(f"{hash}")
}

def ls_tree(argc: i32, argv: &str) {
    let hash = shift_args(&argc, &argv)
    let name_only = false

    if hash == "--name-only" {
        hash = shift_args(&argc, &argv)
        name_only = true
    }

    let object = get_object(hash)

    if object is Tree(li) {
        for entry in li.iter() {
            if name_only {
                println(f"{entry.filename}")
            } else {
                let file_type = if entry.mode == "40000" then "tree" else "blob"
                println(f"{entry.mode.to_i32():06d} {file_type} {entry.hash}    {entry.filename}")
            }
        }
    }
}

def write_tree() {
    let tree = create_tree(".")
    let hash = git::hash_object(tree, write:true)
    tree.free()
    println(f"{hash}")
    hash.free()
}

def commit_tree(argc: i32, argv: &str) {
    let parser = Parser::make("commit tree")
    let tree_hash = parser.add_str("hash", help:"tree hash str")
    let parent = parser.add_str("-p", help:"parent commit")
    let message = parser.add_str("-m", help:"commit message", required:true)
    parser.parse(argc, argv, consume_first:false)
    let parents: $[str] = $[]
    if parent.len() > 0 then parents += parent.copy()

    let commit = create_commit(*tree_hash, parents, *message)
    message.free()
    tree_hash.free()
    for p in parents.iter() {
        p.free()
    }
    parents.free()
    let hash = git::hash_object(commit, write:true)
    println(f"{hash}")
    hash.free()
}

def update_index(argc: i32, argv: &str) {
    let parser = Parser::make("update index")
    let path = parser.add_str("--add", help:"path to the file", required:true)
    parser.parse(argc, argv, consume_first:false)
    let file = fs::read_file(".git/index")
    let index = git::Index::from_buf(file)
    file.free()
    index.add_entry(*path)
    path.free()
    let buf = index.to_buf()
    index.free()
    fs::write_file(".git/index", buf)
    buf.free()
}


// ocen main.oc && ./test.sh ./out <command>